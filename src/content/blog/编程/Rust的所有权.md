---
uid: 20230418220839
title: Rust所有权
tags: [core]
---

# 基本问题

## 为什么要有所有权

==理解堆栈==

堆栈的核心目标是为程序在运行时提供可供使用的内存空间，堆和栈有下列区别：

|      | 栈                                                         | 堆                               |
| ---- | ---------------------------------------------------------- | -------------------------------- |
| 描述 | 存放的数据必须占用已知且固定大小的内存空间                 | 存放的数据可以大小未知且动态改变 |
| 作用 | 存放原始数据和存放堆的大小，地址等信息                     | 存放复杂数据结构                 |
| 性能 | 写入方面，入栈比在堆上分配内存更快，读取在高速缓存，也更快 | 写入和读取都在内存上，慢         |
| 存放 | 高速缓存，往往比内存快十倍以上                             | 内存                             |

==内存泄漏==

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。

==常见内存回收机制==

- 垃圾回收机制：在程序运行时不断寻找不再使用的内存，如 java，go
- 手动管理内存的分配和释放：如 c++
- 通过所有权管理内存：编译器在编译时会根据一系列规则进行检查，程序运行期间不损失任何性能

rust 如果没有所有权机制，就和其它语言一样，内存回收就是个难题。

# 所有权规则

1. Rust 中的每一个值都有一个  **所有者**（_owner_）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

> 我理解的所有权：控制数据的权力，描述的是数据和变量之间的关系。有所有权，能修改数据。

对于存储在栈上的数据，会自动复制，不会转移所有权。否则存储在堆上的数据，会发生转移所有权。常见不会转移所有权的数据类型 (实现了 `Copy` trait)：

- 所有整数类型，比如  `u32`。
- 布尔类型，`bool`，它的值是  `true`  和  `false`。
- 所有浮点数类型，比如  `f64`。
- 字符类型，`char`。
- 元组，当且仅当其包含的类型也都实现  `Copy`  的时候。比如，`(i32, i32)`  实现了  `Copy`，但  `(i32, String)`  就没有。

> 对于普通赋值语法，简单数据类型会自动拷贝后赋值，不涉及所有权的转移。对于复杂数据结构，普通赋值语法会转移所有权。如果不想转移，通过引用的方式访问值。引用分为不可变引用和可变引用，可变引用可修改数据，不可变引用不可修改数据。

### 转移所有权

```rust
let x = 5;
let y = x;
```

将 5 绑定到 x 变量上，之后再自动拷贝 x 的值，绑定到 y 上。不涉及任何分配内存的操作，原始值足够简单。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

因为 `String` 不是基本类型，由存储在 **栈中的堆指针、字符串长度、字符串容量** 共同组成，所以 `s2 = s1` 不是简单的自动拷贝再绑定。分两种情况讨论：

1. 深拷贝：创建一个新内存，拷贝所有 s1 上的数据，对性能影响贼大。如果确实需要，使用 `let s2 = s1.clone()` 实现。
2. 浅拷贝：只改变字符串对应内存上的堆的指针。即 `s1` 上的数据指向 `s2` 变量，速度很快。

但这导致一个数据有两个所有者。如果有两个所有者：

当变量离开作用域后，Rust 会自动调用  `drop`  函数并清理变量的堆内存。不过由于两个  `String`  变量指向了同一位置。这就有了一个问题：当  `s1`  和  `s2`  离开作用域，它们都会尝试释放相同的内存。这是一个叫做  **二次释放（double free）**  的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

因此，Rust 这样解决问题：**当  `s1`  赋予  `s2`  后，Rust 认为  `s1`  不再有效，因此也无需在  `s1`  离开作用域后  `drop`  任何东西，这就是把所有权从  `s1`  转移给了  `s2`，`s1`  在被赋予  `s2`  后就马上失效了**。

## 引用和借用

如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？

- 引用和解引用：不创建新的数据，新变量绑定的是地址
- 不可变引用：不转移所有权而能够访问变量的数据，但不能修改数据
- 可变引用：不转移所有权，能够访问数据和修改数据，但不能有多个可变引用，也不能和可变引用共存

#### 引用与解引用

引用和 C 语言中的指针和地址不一样，在不可变引用里就很明显：

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

把 5 绑定在 x 变量上，然后将 x 的地址绑定到 y 上。访问 y 上的数据，实际是个地址，需要解引用 `*y`。

#### 不可变引用

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

这里，`&`  符号即是引用，它们允许你使用值，但是不获取所有权：

![](https://pic1.zhimg.com/80/v2-fc68ea4a1fe2e3fe4c5bb523a0a8247c_1440w.jpg)

看见没和地址和指针不一样，这个 `s` 就是个指向 `s1` 的变量。但通过 `s`，修改不了 `s1` 指向的值。

```rust
fn main() {
    let s = String::from("hello");

    change(&s); //报错
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

#### 可变引用

将引用也用 `mute` 关键字标记：

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

==可变引用只能存在一个， 可变引用和不可变引用不可同时存在==

这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制
